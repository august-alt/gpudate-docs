"use strict";(self.webpackChunkgpupdate_docs=self.webpackChunkgpupdate_docs||[]).push([[5890],{4278:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var s=n(4848),i=n(8453);const r={},a=void 0,o={id:"gpoa/backend/samba_backend",title:"samba_backend",description:"ClassDef samba_backend",source:"@site/docs/gpoa/backend/samba_backend.md",sourceDirName:"gpoa/backend",slug:"/gpoa/backend/samba_backend",permalink:"/gpupdate-docs/docs/gpoa/backend/samba_backend",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"nodomain_backend",permalink:"/gpupdate-docs/docs/gpoa/backend/nodomain_backend"},next:{title:"applier_frontend",permalink:"/gpupdate-docs/docs/gpoa/frontend/applier_frontend"}},c={},h=[{value:"ClassDef samba_backend",id:"classdef-samba_backend",level:2},{value:"FunctionDef <strong>init</strong>(self, sambacreds, username, domain, is_machine)",id:"functiondef-initself-sambacreds-username-domain-is_machine",level:3},{value:"FunctionDef <strong>del</strong>(self)",id:"functiondef-delself",level:3},{value:"FunctionDef get_policy_mode(self)",id:"functiondef-get_policy_modeself",level:3},{value:"FunctionDef retrieve_and_store(self)",id:"functiondef-retrieve_and_storeself",level:3},{value:"FunctionDef _get_gpts(self, username, sid)",id:"functiondef-_get_gptsself-username-sid",level:3},{value:"FunctionDef upm2str(upm_num)",id:"functiondef-upm2strupm_num",level:2}];function d(e){const t={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"classdef-samba_backend",children:"ClassDef samba_backend"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"samba_backend"}),": The function of the samba_backend class is to serve as a specific implementation of the applier_backend base class, handling the retrieval and storage of Group Policy Objects (GPOs) settings in Samba environments."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"attributes"}),":\n\xb7 ",(0,s.jsx)(t.code,{children:"__user_policy_mode_key"}),": A class-level attribute that stores the registry key for the UserPolicyMode parameter, used to determine if it is possible to work with the user's part of the GPT.\n\xb7 ",(0,s.jsx)(t.code,{children:"cache_path"}),": An instance attribute that stores the path to the cache file for storing Kerberos credentials.\n\xb7 ",(0,s.jsx)(t.code,{children:"__kinit_successful"}),": An instance attribute that indicates whether the Kerberos initialization (kinit) was successful.\n\xb7 ",(0,s.jsx)(t.code,{children:"storage"}),": An instance attribute that represents the registry storage, used to interact with the Windows registry.\n\xb7 ",(0,s.jsx)(t.code,{children:"sid"}),": An instance attribute that stores the Security Identifier (SID) for the machine or user.\n\xb7 ",(0,s.jsx)(t.code,{children:"cache"}),": An instance attribute that represents the cache for registry policies.\n\xb7 ",(0,s.jsx)(t.code,{children:"gpo_names"}),": An instance attribute that stores the names of the GPOs.\n\xb7 ",(0,s.jsx)(t.code,{children:"sambacreds"}),": An instance attribute that stores the Samba credentials, including the domain, username, and password.\n\xb7 ",(0,s.jsx)(t.code,{children:"cache_dir"}),": An instance attribute that stores the directory path for the Samba cache."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Code Description"}),":\nThe samba_backend class is a derived class of applier_backend and is responsible for implementing the ",(0,s.jsx)(t.code,{children:"retrieve_and_store"})," method to handle the retrieval and storage of GPO settings in Samba environments."]}),"\n",(0,s.jsxs)(t.p,{children:["Upon instantiation, the samba_backend class initializes various attributes, including the cache path, Kerberos credentials, registry storage, Samba credentials, and cache directory. The ",(0,s.jsx)(t.code,{children:"__del__"})," method is defined to destroy the Kerberos credentials when the object is deleted."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"get_policy_mode"})," method retrieves the UserPolicyMode parameter value from the registry, which is used to determine if it is possible to work with the user's part of the GPT."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"retrieve_and_store"})," method is responsible for retrieving GPO settings and storing them in a database. It first retrieves the GPOs for the machine and then processes user GPOs if a user's name is specified. The method checks the UserPolicyMode parameter and merges the user and machine GPO settings accordingly."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"_check_sysvol_present"})," method checks if there is a SYSVOL path assigned to a GPO, and the ",(0,s.jsx)(t.code,{children:"_get_gpts"})," method retrieves the GPOs for the specified username and SID."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Relationship with derived classes"}),":\nThe samba_backend class is a derived class of applier_backend and implements the ",(0,s.jsx)(t.code,{children:"retrieve_and_store"})," method to handle GPO settings in Samba environments."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The samba_backend class is not meant to be instantiated directly. Instead, it should be used as a base class for creating specific Samba backend implementations."}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"retrieve_and_store"})," method should be implemented in derived classes to provide the actual logic for retrieving and storing GPO settings."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Output Example"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Instantiating a samba_backend object\nsb = samba_backend(sambacreds, 'username', 'domain', False)\n\n# Retrieving and storing GPO settings\nsb.retrieve_and_store()\n\n# Getting the UserPolicyMode parameter value\nupm = sb.get_policy_mode()\n"})}),"\n",(0,s.jsxs)(t.h3,{id:"functiondef-initself-sambacreds-username-domain-is_machine",children:["FunctionDef ",(0,s.jsx)(t.strong,{children:"init"}),"(self, sambacreds, username, domain, is_machine)"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.strong,{children:"init"})}),": The function of ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.strong,{children:"init"})})," is to initialize the samba_backend object with the necessary parameters and perform some initial operations."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"parameters"}),":\n\xb7 ",(0,s.jsx)(t.code,{children:"sambacreds"}),": An instance of the Smbacreds class, which contains the Samba connection information.\n\xb7 ",(0,s.jsx)(t.code,{children:"username"}),": A string representing the username to be used for authentication.\n\xb7 ",(0,s.jsx)(t.code,{children:"domain"}),": A string representing the domain to which the user belongs.\n\xb7 ",(0,s.jsx)(t.code,{children:"is_machine"}),": A boolean value indicating whether the user is a machine or not."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Code Description"}),":\nThe ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.strong,{children:"init"})})," function initializes the following attributes of the samba_backend object:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"cache_path"}),": A string representing the path to the Kerberos ticket cache file. It is generated using the current process ID and the format ",(0,s.jsx)(t.code,{children:"/var/cache/gpupdate/creds/krb5cc_{}."})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"__kinit_successful"}),": A boolean value indicating whether the Kerberos ticket initialization was successful or not. It is set by calling the ",(0,s.jsx)(t.code,{children:"machine_kinit"})," function with the ",(0,s.jsx)(t.code,{children:"cache_path"})," as an argument. If the function returns ",(0,s.jsx)(t.code,{children:"False"}),", an exception is raised."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"storage"}),": An instance of the `sqlite_"]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.h3,{id:"functiondef-delself",children:["FunctionDef ",(0,s.jsx)(t.strong,{children:"del"}),"(self)"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"__del__"})}),": The ",(0,s.jsx)(t.code,{children:"__del__"})," function is a special method in Python, called when an object is about to be destroyed. In this specific case, it is used to ensure that any machine credentials are removed before the ",(0,s.jsx)(t.code,{children:"samba_backend"})," object is deleted."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"parameters"}),": This function does not take any parameters."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"__del__"})," function checks if the ",(0,s.jsx)(t.code,{children:"__kinit_successful"})," attribute is ",(0,s.jsx)(t.code,{children:"True"}),". If it is, it means that machine credentials have been obtained and stored in a Kerberos ticket cache."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.code,{children:"__kinit_successful"})," is ",(0,s.jsx)(t.code,{children:"True"}),", the ",(0,s.jsx)(t.code,{children:"machine_kdestroy()"})," function is called. This function securely removes the Kerberos ticket cache for the machine, which is used for authentication in a Kerberos environment."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["By calling ",(0,s.jsx)(t.code,{children:"machine_kdestroy()"}),", any machine credentials are removed before the ",(0,s.jsx)(t.code,{children:"samba_backend"})," object is deleted, ensuring that sensitive information is not left behind."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"__del__"})," function should be used carefully, as it is called when an object is about to be destroyed. Make sure that any necessary cleanup or finalization tasks are performed within this function."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"__del__"})," function relies on the ",(0,s.jsx)(t.code,{children:"machine_kdestroy()"})," function to remove Kerberos ticket caches. Make sure that the ",(0,s.jsx)(t.code,{children:"machine_kdestroy()"})," function is working as expected, as incorrect behavior could lead to unexpected consequences."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"__del__"})," function is called automatically by Python, and its execution is not guaranteed. In some cases, the ",(0,s.jsx)(t.code,{children:"__del__"})," function may not be called if the Python interpreter is terminated abruptly or if the object is part of a cyclic garbage collection. Therefore, it should not be used for critical tasks that must be performed before an object is destroyed."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h3,{id:"functiondef-get_policy_modeself",children:"FunctionDef get_policy_mode(self)"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"get_policy_mode"}),": The function of get_policy_mode is to retrieve the UserPolicyMode parameter value from the HKLM (HKEY_LOCAL_MACHINE) table in the SQLite database. This value is used to determine if it is possible to work with the user's part of GPT (Group Policy Template)."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"parameters"}),":\n\xb7 self: The instance of the samba_backend class."]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h3,{id:"functiondef-retrieve_and_storeself",children:"FunctionDef retrieve_and_store(self)"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"retrieve_and_store"}),": The function of retrieve_and_store is to retrieve and store machine and user settings from the Windows registry to a SQLite database."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"parameters"}),": The parameters of this Function are as follows:\n\xb7 self: The object that calls this function.\n\xb7 machine_username: A boolean value indicating whether to store the machine username in the database."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,s.jsx)(t.p,{children:"The retrieve_and_store function is defined in the gpoa/backend/nodomain_backend.py module and is responsible for retrieving machine and user settings from the Windows registry and storing them in a SQLite database. It is primarily called by the gpoa/backend/backend.py module's start_backend_process function."}),"\n",(0,s.jsx)(t.p,{children:"The function begins by wiping the HKLM and machine_sid user settings in the storage object. It then calls the get_machine_name function to get the localhost name and sets it as the machine_name attribute of the nodomain_backend object."}),"\n",(0,s.jsx)(t.p,{children:"Next, the function retrieves the machine settings from the registry by calling the get_machine_settings function and stores them in the machine_settings attribute of the nodomain_backend object. It then calls the merge_machine function to merge the machine settings to the storage object."}),"\n",(0,s.jsx)(t.p,{children:"After that, the function retrieves the user settings from the registry by calling the get_user_settings function and stores them in the user_settings attribute of the nodomain_backend object. It then calls the merge_user function to merge the user settings to the storage object."}),"\n",(0,s.jsx)(t.p,{children:"Finally, the function sets the machine_username attribute of the nodomain_backend object to the machine_username parameter."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Relationship with its callers in the project"}),":"]}),"\n",(0,s.jsx)(t.p,{children:"The retrieve_and_store function is primarily called by the start_backend_process function in the gpoa/backend/backend.py module. In this function, the retrieve_and_store function is called with the machine_username parameter set to True if the backend type is nodomain, and False otherwise."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function assumes that the get_machine_name, get_machine_settings, get_user_settings, merge_machine, and merge_user functions have been called and have initialized the necessary variables."}),"\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function is only intended to be called with a valid machine and user settings dictionary."}),"\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function should be used carefully to ensure that the machine and user settings are retrieved and stored correctly to the storage object."}),"\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function should be updated if new preference types are added to the project."}),"\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function should be used consistently throughout the project to ensure that all machine and user settings are retrieved and stored correctly to the storage object.\nRaw code:```\ndef retrieve_and_store(self, machine_username):\n'''\nRetrieve and store machine and user settings from the Windows registry to a SQLite database.\n'''\nself.wipe_hklm()\nself.wipe_machine_sid()\nself.machine_name = get_machine_name()\nself.machine_settings = get_machine_settings()\nself.merge_machine()\nself.user_settings = get_user_settings()\nself.merge_user()\nself.machine_username = machine_username"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-==========",children:'obj: gpoa/backend/nodomain_backend.py/nodomain\\_backend/get\\_machine\\_settings\nDocument: \n **get\\_machine\\_settings**: The function of get\\_machine\\_settings is to retrieve machine settings from the Windows registry.\n\n**parameters**: This function does not take any parameters.\n\n**Code Description**:\n\nThe get\\_machine\\_settings function is defined in the gpoa/backend/nodomain\\_backend.py module and is responsible for retrieving machine settings from the Windows registry. It is primarily called by the retrieve\\_and\\_store function in the nodomain\\_backend module.\n\nThe function begins by initializing an empty dictionary called machine\\_settings. It then iterates over the items in the HKLM hive of the Windows registry, excluding the \'SOFTWARE\' key. For each item, it gets the preference\\_type using the get\\_preftype function, passing in the preference\\_path value as the path\\_to\\_file parameter. It then gets the parser function using the get\\_parser function, passing in the preference\\_type constant as the preference\\_type parameter. The parser function is then called with the preference\\_path value as the parameter, and the result is stored\n***\n### FunctionDef _check_sysvol_present(self, gpo)\n **`_check_sysvol_present`**: The function of `_check_sysvol_present` is to check if there is a SYSVOL path for a given Group Policy Object (GPO).\n\n**parameters**:\n\xb7 `gpo`: An instance of the `gpoa.backend.samba_backend.GroupPolicyObject` class representing a GPO.\n\n**Code Description**:\n\nThe function `_check_sysvol_present` first checks if the `gpo` object has a `file_sys_path` attribute. If this attribute is not present, the function checks if the name of the GPO is "Local Policy". If the name is not "Local Policy", a warning message is logged using the `log` function from the `gpoa.util.logging` module. The warning message includes the name of the GPO. The function then returns `False`, indicating that there is no SYSVOL path for the GPO.\n\nIf the `file_sys_path` attribute is present, the function returns `True`, indicating that there is a SYSVOL path for the GPO.\n\nThe `log` function is used to log informational, warning, and error messages. It takes two arguments: a message code and an optional data dictionary. The message code is used to look up the message string in a message catalog, and the data dictionary is used to substitute variables into the message string.\n\nThe `_check_sysvol_present` function is called by the `_get_gpts` function in the `gpoa.backend.samba_backend` module. The `_get_gpts` function retrieves a list of GPOs for a given user and SID, and for each GPO, it checks if there is a SYSVOL path using the `_check_sysvol_present` function. If there is a SYSVOL path, the function creates a `gpt` object and adds it to a list of GPTs. If the GPO is the "Local Policy" GPO, the function creates a `LocalGPT` object and adds it to the list of GPTs.\n\n**Note**:\n\nThe `_check_sysvol_present` function assumes that the `gpo` object has a `file_sys_path` attribute or a `name` attribute. If the `gpo` object does not have these attributes, the function may raise an `AttributeError` exception.\n\n**Output Example**:\n\nThe `_check_sysvol_present` function returns `False` if there is no SYSVOL path for the GPO, and `True` if there is a SYSVOL path for the GPO. Here is an example output:\n\n```python\n>>> gpo = GroupPolicyObject(name="Test GPO", file_sys_path="/path/to/sysvol/Test GPO")\n>>> result = _check_sysvol_present(gpo)\n>>> print(result)\nTrue\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In this example, the ",(0,s.jsx)(t.code,{children:"_check_sysvol_present"})," function returns ",(0,s.jsx)(t.code,{children:"True"})," because the ",(0,s.jsx)(t.code,{children:"gpo"})," object has a ",(0,s.jsx)(t.code,{children:"file_sys_path"})," attribute."]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h3,{id:"functiondef-_get_gptsself-username-sid",children:"FunctionDef _get_gpts(self, username, sid)"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"retrieve_and_store"}),": The function of retrieve_and_store is to retrieve the settings from the Group Policy Objects (GPOs) and store them in a database."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"parameters"}),": The parameters of this Function.\n\xb7 self: The instance of the samba_backend class."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Code Description"}),": The description of this Function.\nThe retrieve_and_store function is called when the user wants to retrieve the settings from the GPOs and store them in a database. It first retrieves the GPOs for the machine by calling the _get_gpts function with the machine name and machine SID as parameters. If the user's name is specified, it also retrieves the user GPOs by calling the _get_gpts function with the user name and user SID as parameters."]}),"\n",(0,s.jsx)(t.p,{children:"The function then wipes the HKEY_LOCAL_MACHINE (HKLM) and user keys from the storage object. For each GPO object in the machine_gpts list, it calls the merge_machine function to merge the machine settings to the storage object. If the user's name is specified, it also calls the merge_user function for each GPO object in the user_gpts list to merge the user settings to the storage object."}),"\n",(0,s.jsx)(t.p,{children:"The function also checks the policy mode and merges the user settings accordingly. If the policy mode is set to 1, it merges the user settings for HKEY_CURRENT_USER (HKCU) only. If the policy mode is set to 2, it merges the user settings for HKLM and HKCU."}),"\n",(0,s.jsx)(t.p,{children:"The retrieve_and_store function is called in the gpoa/backend/samba_backend.py/samba_backend/apply_settings function to retrieve the settings from the GPOs and apply them to the system."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),": Points to note about the use of the code"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function assumes that the _get_gpts function has been implemented and is working correctly."}),"\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function modifies the storage object, so any changes made to it will be reflected in the system."}),"\n",(0,s.jsx)(t.li,{children:"The retrieve_and_store function can raise exceptions if there are any errors while merging the settings to the storage object."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Output Example"}),": Mock up a possible appearance of the code's return value."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"retrieve_and_store('machine_name', 'machine_sid', 'user_name', 'user_sid')\nprint(storage.get_info('hklm'))  # Output: The merged machine settings\nprint(storage.get_info('user'))  # Output: The merged user settings\n"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"functiondef-upm2strupm_num",children:"FunctionDef upm2str(upm_num)"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"upm2str"}),": The function of upm2str is to translate UserPolicyMode (UPM) to a string."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"parameters"}),":\nThis function takes one parameter:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"upm_num: A number representing the UserPolicyMode. It can be an integer or a string."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Code Description"}),":\nThe function initializes the result variable with the string 'Not configured'. It then checks if the upm_num parameter is equal to 1 or '1', and if so, sets the result variable to 'Merge'. If upm_num is equal to 2 or '2', the result variable is set to 'Replace'. Finally, the function returns the result variable."]}),"\n",(0,s.jsxs)(t.p,{children:["This function is used to provide a human-readable representation of the UserPolicyMode. It is called in the ",(0,s.jsx)(t.code,{children:"retrieve_and_store"})," method of the ",(0,s.jsx)(t.code,{children:"samba_backend"})," class, where it is used to log the policy mode in a more readable format."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The function accepts both integer and string values for the upm_num parameter, providing flexibility in its use."}),"\n",(0,s.jsx)(t.li,{children:"It is important to note that the function only checks for exact matches of 1, 2, '1', and '2'. Any other value passed as the upm_num parameter will result in the 'Not configured' string being returned."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Output Example"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"'Merge'\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is an example of what the function might return when called with an upm_num parameter of 1 or '1'."})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);