"use strict";(self.webpackChunkgpupdate_docs=self.webpackChunkgpupdate_docs||[]).push([[1400],{6889:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var i=s(4848),n=s(8453);const r={},c=void 0,o={id:"gpoa/frontend/scripts_applier",title:"scripts_applier",description:"ClassDef scripts_applier",source:"@site/docs/gpoa/frontend/scripts_applier.md",sourceDirName:"gpoa/frontend",slug:"/gpoa/frontend/scripts_applier",permalink:"/gpupdate-docs/docs/gpoa/frontend/scripts_applier",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"polkit_applier",permalink:"/gpupdate-docs/docs/gpoa/frontend/polkit_applier"},next:{title:"shortcut_applier",permalink:"/gpupdate-docs/docs/gpoa/frontend/shortcut_applier"}},l={},a=[{value:"ClassDef scripts_applier",id:"classdef-scripts_applier",level:2},{value:"FunctionDef <strong>init</strong>(self, storage, sid)",id:"functiondef-initself-storage-sid",level:3},{value:"FunctionDef cleaning_cache(self)",id:"functiondef-cleaning_cacheself",level:3},{value:"FunctionDef filling_cache(self)",id:"functiondef-filling_cacheself",level:3},{value:"FunctionDef run(self)",id:"functiondef-runself",level:3},{value:"FunctionDef apply(self)",id:"functiondef-applyself",level:3},{value:"ClassDef scripts_applier_user",id:"classdef-scripts_applier_user",level:2},{value:"FunctionDef <strong>init</strong>(self, storage, sid, username)",id:"functiondef-initself-storage-sid-username",level:3},{value:"FunctionDef cleaning_cache(self)",id:"functiondef-cleaning_cacheself-1",level:3},{value:"FunctionDef filling_cache(self)",id:"functiondef-filling_cacheself-1",level:3},{value:"FunctionDef user_context_apply(self)",id:"functiondef-user_context_applyself",level:3},{value:"FunctionDef run(self)",id:"functiondef-runself-1",level:3},{value:"FunctionDef admin_context_apply(self)",id:"functiondef-admin_context_applyself",level:3},{value:"FunctionDef install_script(storage_script_entry, script_dir, access_permissions)",id:"functiondef-install_scriptstorage_script_entry-script_dir-access_permissions",level:2}];function h(e){const t={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"classdef-scripts_applier",children:"ClassDef scripts_applier"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"scripts_applier"}),": The ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is a subclass of ",(0,i.jsx)(t.code,{children:"applier_frontend"})," and is responsible for handling scripts-related operations in the gpoa project. It serves as a frontend module that applies policies related to scripts."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"attributes"}),":\n\xb7 ",(0,i.jsx)(t.code,{children:"storage"}),": An instance of the storage class, which is used to interact with the Windows Registry and other storage mechanisms.\n\xb7 ",(0,i.jsx)(t.code,{children:"sid"}),": The security identifier (SID) of the user or machine for which policies are being applied.\n\xb7 ",(0,i.jsx)(t.code,{children:"startup_scripts"}),": A list of startup scripts for the current SID.\n\xb7 ",(0,i.jsx)(t.code,{children:"shutdown_scripts"}),": A list of shutdown scripts for the current SID.\n\xb7 ",(0,i.jsx)(t.code,{children:"folder_path"}),": The file path to the scripts cache folder."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is a subclass of ",(0,i.jsx)(t.code,{children:"applier_frontend"})," and is responsible for handling scripts-related operations in the gpoa project. It initializes the ",(0,i.jsx)(t.code,{children:"storage"})," and ",(0,i.jsx)(t.code,{children:"sid"})," attributes in its constructor, and sets the ",(0,i.jsx)(t.code,{children:"startup_scripts"})," and ",(0,i.jsx)(t.code,{children:"shutdown_scripts"})," attributes based on the result of a call to ",(0,i.jsx)(t.code,{children:"storage.get_scripts()"}),". The ",(0,i.jsx)(t.code,{children:"folder_path"})," attribute is set to the scripts cache folder path."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"cleaning_cache()"})," method removes the contents of the scripts cache folder. The ",(0,i.jsx)(t.code,{children:"filling_cache()"})," method creates and updates the scripts cache folder and copies the startup and shutdown scripts to the appropriate subfolders."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"run()"})," method is called by the ",(0,i.jsx)(t.code,{children:"apply()"})," method and is responsible for filling the scripts cache folder with the necessary scripts."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"apply()"})," method checks whether the current module is enabled before calling ",(0,i.jsx)(t.code,{children:"run()"}),". If the module is enabled, it fills the scripts cache folder with the necessary scripts. If the module is not enabled, it logs a message indicating that the module is not enabled."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is intended to be used as a frontend module that applies policies related to scripts in the gpoa project. It is initialized with a ",(0,i.jsx)(t.code,{children:"storage"})," object and a ",(0,i.jsx)(t.code,{children:"sid"}),", and its ",(0,i.jsx)(t.code,{children:"apply()"})," method is called to apply the necessary scripts."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is used in the ",(0,i.jsx)(t.code,{children:"_init_machine_appliers()"})," method of the ",(0,i.jsx)(t.code,{children:"frontend_manager"})," class to initialize the ",(0,i.jsx)(t.code,{children:"scripts"})," key of the ",(0,i.jsx)(t.code,{children:"machine_appliers"})," dictionary. This allows the ",(0,i.jsx)(t.code,{children:"frontend_manager"})," class to manage and apply policies related to scripts using the ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":\nThe ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is intended to be used as a frontend module that applies policies related to scripts in the gpoa project. It should be initialized with a ",(0,i.jsx)(t.code,{children:"storage"})," object and a ",(0,i.jsx)(t.code,{children:"sid"}),", and its ",(0,i.jsx)(t.code,{children:"apply()"})," method should be called to apply the necessary scripts. The ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is not intended to be used directly by end-users, but rather as a component of the larger gpoa project."]}),"\n",(0,i.jsxs)(t.h3,{id:"functiondef-initself-storage-sid",children:["FunctionDef ",(0,i.jsx)(t.strong,{children:"init"}),"(self, storage, sid)"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})}),": The function of ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})})," is to initialize the scripts applier object with the required parameters and set up the necessary attributes for the object."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 storage: An instance of the SQLiteRegistry class, which provides access to the scripts registry.\n\xb7 sid: A unique identifier for the user or system, which is used to filter the scripts based on the user or system."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})})," function initializes the object by setting the ",(0,i.jsx)(t.code,{children:"storage"})," and ",(0,i.jsx)(t.code,{children:"sid"})," attributes with the provided parameters. Then, it calls the ",(0,i.jsx)(t.code,{children:"get_scripts"})," method of the ",(0,i.jsx)(t.code,{children:"storage"})," object to retrieve the list of startup and shutdown scripts for the given ",(0,i.jsx)(t.code,{children:"sid"}),". The retrieved scripts are stored in the ",(0,i.jsx)(t.code,{children:"startup_scripts"})," and ",(0,i.jsx)(t.code,{children:"shutdown_scripts"})," attributes, respectively."]}),"\n",(0,i.jsxs)(t.p,{children:["The function also creates a folder path for caching the scripts using the ",(0,i.jsx)(t.code,{children:"__cache_scripts"})," attribute, which is a class-level attribute defined in the ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class. The folder path is created using the ",(0,i.jsx)(t.code,{children:"Path"})," class from the ",(0,i.jsx)(t.code,{children:"pathlib"})," module."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, the function calls the ",(0,i.jsx)(t.code,{children:"check_enabled"})," function with the ",(0,i.jsx)(t.code,{children:"storage"})," object and the ",(0,i.jsx)(t.code,{children:"__module_name"})," and ",(0,i.jsx)(t.code,{children:"__module_experimental"})," attributes to determine whether the module is enabled or not. The ",(0,i.jsx)(t.code,{children:"check_enabled"})," function returns a boolean value, which is stored in the ",(0,i.jsx)(t.code,{children:"__module_enabled"})," attribute."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"__init__"})," function is called when a new instance of the ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class is created. It sets up the necessary attributes for the object, which are used by other methods in the class to apply the scripts."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"get_scripts"})," method of the ",(0,i.jsx)(t.code,{children:"storage"})," object is called with the ",(0,i.jsx)(t.code,{children:"sid"})," and ",(0,i.jsx)(t.code,{children:"'STARTUP'"})," or ",(0,i.jsx)(t.code,{children:"'SHUTDOWN'"})," parameters to retrieve the startup and shutdown scripts, respectively."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"check_enabled"})," function is called with the ",(0,i.jsx)(t.code,{children:"storage"})," object and the ",(0,i.jsx)(t.code,{children:"__module_name"})," and ",(0,i.jsx)(t.code,{children:"__module_experimental"})," attributes to determine whether the module is enabled or not."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"__cache_scripts"})," attribute is a class-level attribute defined in the ",(0,i.jsx)(t.code,{children:"scripts_applier"})," class, which is used to create the folder path for caching the scripts."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"Path"})," class from the ",(0,i.jsx)(t.code,{children:"pathlib"})," module is used to create the folder path for caching the scripts."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"__init__"})," function initializes the object and sets up the necessary attributes for the object, which are used by other methods in the class to apply the scripts."]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-cleaning_cacheself",children:"FunctionDef cleaning_cache(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"cleaning_cache"}),": The function of cleaning_cache is to remove the directory tree of the folder_path, ignoring any file or directory that is not found."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 ",(0,i.jsx)(t.strong,{children:"self"}),": The instance of the class that the cleaning_cache method belongs to."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe cleaning_cache function begins by calling the log function with the message code 'D160', which logs an informational message indicating that the cache cleaning process has started."]}),"\n",(0,i.jsx)(t.p,{children:"Then, the function attempts to remove the directory tree of the folder_path by calling the remove_dir_tree function, passing in the folder_path and setting the delete_files, delete_folder, and delete_sub_folders parameters to True. This means that the function will delete all files, folders, and sub-folders within the folder_path."}),"\n",(0,i.jsx)(t.p,{children:"If a FileNotFoundError exception is raised, it means that the directory tree to be removed has already been removed by another process, and the function logs the message code 'D154' using the log function."}),"\n",(0,i.jsx)(t.p,{children:"If any other exception is raised, the function creates a dictionary called logdata with the exception as the value of the 'exc' key and logs the message code 'E64' along with the logdata dictionary using the log function."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Relation with Callers"}),":\nThe cleaning_cache function is called by the apply function of the scripts_applier class in the gpoa/frontend/scripts_applier.py/scripts_applier module. The apply function calls the cleaning_cache function to remove the cache directory and its contents before running the module."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":\n\xb7 Be cautious when using this function, as it permanently deletes files and directories. Ensure that the folder_path parameter points to the correct directory and that the function is called only when necessary.\n\xb7 The function handles the FileNotFoundError exception, but it is recommended to handle other exceptions that may occur during the removal of the directory tree."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-filling_cacheself",children:"FunctionDef filling_cache(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"filling_cache"}),": The function of filling_cache is to create and update folder directories for scripts and copy them to the appropriate locations based on their type (STARTUP or SHUTDOWN)."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 self: The instance of the class that the filling_cache method belongs to."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-runself",children:"FunctionDef run(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"run"}),": The function of run is to execute the script application process by calling the filling_cache function."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 self: The instance of the class that the run method belongs to."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe run function initializes the script application process by calling the filling_cache method, which is responsible for creating and updating folder directories for scripts and copying them to the appropriate locations based on their type (STARTUP or SHUTDOWN). This function does not take any additional arguments, as it operates on the object's state."]}),"\n",(0,i.jsx)(t.p,{children:"The run function is called within the apply method, which is responsible for the overall script application process. The apply method first calls the cleaning_cache function to clean up any previous cache, and then checks if the module is enabled. If the module is enabled, it proceeds to call the run function, initiating the script application process."}),"\n",(0,i.jsx)(t.p,{children:"It is important to note that the run function is only called when the module is enabled, as determined by the apply function. This ensures that the script application process is only executed when the module is in an active state."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The run function should only be called within the context of the apply function, and should not be called directly."}),"\n",(0,i.jsx)(t.li,{children:"The run function relies on the filling_cache function to create and update the necessary folder directories and copy the scripts. Therefore, any changes to the filling_cache function may affect the behavior of the run function."}),"\n",(0,i.jsx)(t.li,{children:"The run function is only executed when the module is enabled, as determined by the apply function."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-applyself",children:"FunctionDef apply(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"apply"}),": The function of apply is to perform the script application process by cleaning the cache and executing the module if it is enabled."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 ",(0,i.jsx)(t.strong,{children:"self"}),": The instance of the class that the apply method belongs to."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"classdef-scripts_applier_user",children:"ClassDef scripts_applier_user"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"scripts_applier_user"}),": The function of scripts_applier_user is to manage and apply scripts for users in the gpoa project."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"attributes"}),":\n\xb7 storage: An instance of the storage class, which is used to interact with the Windows Registry and other storage mechanisms.\n\xb7 sid: The security identifier (SID) of the user or machine for which scripts are being applied.\n\xb7 username: The username for which scripts are being applied, if applicable.\n\xb7 logon_scripts: A list of logon scripts for the user.\n\xb7 logoff_scripts: A list of logoff scripts for the user.\n\xb7 folder_path: The path to the cache directory for the user's scripts.\n\xb7 __module_name: The name of the module.\n\xb7 __module_experimental: A flag indicating if the module is experimental.\n\xb7 __module_enabled: A flag indicating if the module is enabled."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nscripts_applier_user is a subclass of applier_frontend, and it is used to manage and apply scripts for users in the gpoa project. The __init__() method initializes the storage, sid, and username attributes, and sets the logon_scripts and logoff_scripts attributes by calling the storage.get_scripts() method. It also sets the folder_path attribute to the path of the cache directory for the user's scripts. The __module_enabled attribute is set based on the result of a call to check_enabled()."]}),"\n",(0,i.jsx)(t.p,{children:"The filling_cache() method creates and updates the folder directories for the user's scripts and copies the scripts to the cache directory."}),"\n",(0,i.jsx)(t.p,{children:"The cleaning_cache() method removes the cache directory for the user's scripts."}),"\n",(0,i.jsx)(t.p,{children:"The user_context_apply() method is intended to be overridden by subclasses to provide the logic for applying scripts in the user context."}),"\n",(0,i.jsx)(t.p,{children:"The run() method calls the filling_cache() method."}),"\n",(0,i.jsx)(t.p,{children:"The admin_context_apply() method calls the cleaning_cache() method and the run() method if the module is enabled."}),"\n",(0,i.jsx)(t.p,{children:"The scripts_applier_user class is intended to be used as a part of the frontend_manager's user appliers, which is used to manage and apply various settings and configurations for users in the gpoa project."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":\nThe scripts_applier_user class is intended to be used as a part of the frontend_manager's user appliers, and it should not be used directly. The class is responsible for managing and applying scripts for users, and it should not be used to manage and apply other settings and configurations. The filling_cache() and cleaning_cache() methods should not be called directly, they are intended to be called by the run() and cleaning_cache() methods respectively. The user_context_apply() method is intended to be overridden by subclasses to provide the logic for applying scripts in the user context."]}),"\n",(0,i.jsxs)(t.h3,{id:"functiondef-initself-storage-sid-username",children:["FunctionDef ",(0,i.jsx)(t.strong,{children:"init"}),"(self, storage, sid, username)"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})}),": The function of ",(0,i.jsx)(t.strong,{children:"init"})," in the scripts_applier_user module is to initialize the scripts_applier_user class with the required parameters and set up the necessary attributes for the class."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 storage: The storage object that contains the information about the scripts.\n\xb7 sid: An integer representing the script ID.\n\xb7 username: A string representing the username for which the scripts are to be applied."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.storage = storage"}),": This line initializes the storage attribute of the class with the provided storage object. The storage object contains the information about the scripts and is used to retrieve the scripts for the given sid and action."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.sid = sid"}),": This line initializes the sid attribute of the class with the provided sid. The sid is used to retrieve the scripts for the given user and action."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.logon_scripts = self.storage.get_scripts(self.sid, 'LOGON')"}),": This line retrieves the logon scripts for the given sid using the get_scripts method of the storage object. The retrieved scripts are stored in the logon_scripts attribute of the class."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.logoff_scripts = self.storage.get_scripts(self.sid, 'LOGOFF')"}),": This line retrieves the logoff scripts for the given sid using the get_scripts method of the storage object. The retrieved scripts are stored in the logoff_scripts attribute of the class."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.username = username"}),": This line initializes the username attribute of the class with the provided username. The username is used to create the folder path for the scripts."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.folder_path = Path(self.__cache_scripts + self.username)"}),": This line creates the folder path for the scripts using the provided cache scripts directory and the username. The folder path is stored in the folder_path attribute of the class."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.__module_enabled = check_enabled(self.storage , self.__module_name , self.__module_experimental)"}),": This line checks if the module is enabled or not using the check_enabled function. The function takes the storage object, module name, and module experimental status as parameters. The result is stored in the _module_enabled attribute of the class."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"self.filling_cache()"}),": This line calls the filling_cache method of the class to create and update the folder directories for the scripts and copy them according to their types (LOGON or LOGOFF)."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"init"})," function is called when a new instance of the scripts_applier_user class is created. It initializes the necessary attributes for the class and sets up the required parameters for the class. The function is used to ensure that the necessary parameters are provided to the class and the required attributes are set up correctly."]}),"\n",(0,i.jsx)(t.p,{children:"The function is called in the scripts_applier module to initialize the scripts_applier_user class with the required parameters and set up the necessary attributes for the class. The function is called after the scripts_applier class is initialized with the required parameters."}),"\n",(0,i.jsx)(t.p,{children:"The function is called with the storage object, sid, and username as parameters. The storage object contains the information about the scripts, the sid is used to retrieve the scripts for the given user and action, and the username is used to create the folder path for the scripts."}),"\n",(0,i.jsx)(t.p,{children:"The function initializes the necessary attributes for the class and sets up the required parameters for the class. It retrieves the logon and logoff scripts for the given sid using the get_scripts method of the storage object. It creates the folder path for the scripts using the provided cache scripts directory and the username. It checks if the module is enabled or not using the check_enabled function. Finally, it calls the filling_cache method of the class to create and update the folder directories for the scripts and copy them according to their types (LOGON or LOGOFF)."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Ensure that valid storage, sid, and username parameters are provided to initialize the scripts_applier_user class correctly."}),"\n",(0,i.jsx)(t.li,{children:"The function initializes the necessary attributes for the class and sets up the required parameters for the class."}),"\n",(0,i.jsx)(t.li,{children:"The function retrieves the logon and logoff scripts for the given sid using the get_scripts method of the storage object."}),"\n",(0,i.jsx)(t.li,{children:"The function creates the folder path for the scripts using the provided cache scripts directory and the username."}),"\n",(0,i.jsx)(t.li,{children:"The function checks if the module is enabled or not using the check_enabled function."}),"\n",(0,i.jsx)(t.li,{children:"The function calls the filling_cache method of the class to create and update the folder directories for the scripts and copy them according to their types (LOGON or LOGOFF)."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-cleaning_cacheself-1",children:"FunctionDef cleaning_cache(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"cleaning_cache"}),": The function of cleaning_cache is to remove the directory tree of the cache folder."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 None: This function does not take any parameters."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe cleaning_cache function performs the following steps:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"It calls the log function with the message code 'D161' to log the start of the cache cleaning process."}),"\n",(0,i.jsx)(t.li,{children:"It then tries to remove the directory tree of the folder_path using the remove_dir_tree function. If the directory tree does not exist, a FileNotFoundError exception is raised, which is caught and logged with the message code 'D155'."}),"\n",(0,i.jsx)(t.li,{children:"If any other exception occurs during the removal process, the exception object is logged with the message code 'E65' along with additional log data."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Relation with Callers"}),":\nThe cleaning_cache function is called by the admin_context_apply function in the same module (gpoa/frontend/scripts_applier.py/scripts_applier_user/admin_context_apply) and the cleaning_cache function in the parent module (gpoa/frontend/scripts_applier.py/scripts_applier_user/cleaning_cache). The purpose of calling this function is to remove the cache directory and its contents before applying scripts or administrative contexts."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The function does not return any value."}),"\n",(0,i.jsx)(t.li,{children:"The function removes the directory tree of the folder_path, which includes all files and subdirectories. Be cautious while using this function as it permanently deletes the specified directory and its contents."}),"\n",(0,i.jsx)(t.li,{children:"Ensure that the folder_path variable is correctly set to the desired cache directory before calling this function."}),"\n",(0,i.jsx)(t.li,{children:"If the remove_dir_tree function encounters any issues (such as permission errors), they will be logged with the message code 'E65'."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-filling_cacheself-1",children:"FunctionDef filling_cache(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"filling_cache"}),": The function of filling_cache in the scripts_applier_user module is to create and update folder directories for scripts and copy them according to their types (LOGON or LOGOFF)."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 self: The instance of the scripts_applier_user class."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-user_context_applyself",children:"FunctionDef user_context_apply(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"user_context_apply"}),": The function of user_context_apply is to apply user context."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": This function does not take any parameters."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsx)(t.p,{children:'The user_context_apply function is a method of the scripts_applier_user class, which is defined in the scripts_applier.py module. This function does not contain any code implementation, as indicated by the "pass" statement. It is likely that this function is intended to serve as a placeholder for future implementation.'}),"\n",(0,i.jsx)(t.p,{children:"When called, the user_context_apply function will not perform any actions. However, since it is a part of the scripts_applier_user class, it may be intended to be used in conjunction with other methods in the class to apply user context in a larger workflow."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"This function does not contain any implementation and should be implemented according to the specific requirements of the project."}),"\n",(0,i.jsx)(t.li,{children:'It is important to note that the name of the function, "user_context_apply", suggests that it is intended to apply user context. Therefore, any implementation should include functionality to apply user context.'}),"\n",(0,i.jsx)(t.li,{children:"Developers should ensure that the function is used appropriately in the larger context of the scripts_applier_user class and the overall project."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-runself-1",children:"FunctionDef run(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"run"}),": The function of run is to initiate the script application process by calling the filling_cache function."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 self: The instance of the scripts_applier_user class."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe run function is a method of the scripts_applier_user class, and it does not take any arguments other than the instance of the class itself. When called, it invokes the filling_cache method, which is responsible for creating and updating folder directories for scripts and copying them according to their types (LOGON or LOGOFF). The run function does not return any value."]}),"\n",(0,i.jsx)(t.p,{children:"The run function plays a crucial role in the script application process. It is called in the admin_context_apply function, which is responsible for applying the scripts in the admin context. The admin_context_apply function first calls the cleaning_cache method to remove any stale scripts from the cache directory. Then, it checks if the module is enabled, and if so, it calls the run function to initiate the script application process."}),"\n",(0,i.jsx)(t.p,{children:"It is important to note that the run function relies on the filling_cache function to create and update the script directories. Therefore, any issues with the filling_cache function may affect the proper functioning of the run function. Additionally, the run function should only be called in the context of the scripts_applier_user class, as it relies on the class instance to access the necessary variables and methods."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The run function should only be called in the context of the scripts_applier_user class."}),"\n",(0,i.jsx)(t.li,{children:"Any issues with the filling_cache function may affect the proper functioning of the run function."}),"\n",(0,i.jsx)(t.li,{children:"The run function does not return any value."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-admin_context_applyself",children:"FunctionDef admin_context_apply(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"admin_context_apply"}),": The function of admin_context_apply is to apply the administrative context after cleaning the cache if the module is enabled."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": This function does not take any parameters."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsx)(t.p,{children:"The admin_context_apply function performs the following steps:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"It calls the cleaning_cache function to remove the directory tree of the cache folder. This is done to ensure that any stale scripts from the cache directory are removed before applying scripts or administrative contexts."}),"\n",(0,i.jsxs)(t.li,{children:["It checks if the module is enabled by checking the value of the ",(0,i.jsx)(t.code,{children:"self.__module_enabled"})," attribute. If the module is enabled, it proceeds to the next step. Otherwise, it logs the message 'D159' using the log function."]}),"\n",(0,i.jsx)(t.li,{children:"If the module is enabled, it logs the message 'D158' using the log function and then calls the run function to initiate the script application process."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Relation with Callers"}),":"]}),"\n",(0,i.jsxs)(t.p,{children:["The admin_context_apply function is called by the ",(0,i.jsx)(t.code,{children:"scripts_applier_user"})," class. It is called after the ",(0,i.jsx)(t.code,{children:"cleaning_cache"})," function and before the ",(0,i.jsx)(t.code,{children:"run"})," function in the ",(0,i.jsx)(t.code,{children:"admin_context_apply"})," method of the ",(0,i.jsx)(t.code,{children:"scripts_applier_user"})," class."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The function does not return any value."}),"\n",(0,i.jsx)(t.li,{children:"The function removes the directory tree of the cache folder, which includes all files and subdirectories. Be cautious while using this function as it permanently deletes the specified directory and its contents."}),"\n",(0,i.jsxs)(t.li,{children:["Ensure that the ",(0,i.jsx)(t.code,{children:"scripts_applier_user"})," class is correctly configured and the ",(0,i.jsx)(t.code,{children:"__module_enabled"})," attribute is set to ",(0,i.jsx)(t.code,{children:"True"})," before calling this function."]}),"\n",(0,i.jsx)(t.li,{children:"If any issues occur during the execution of this function, they will be logged using the log function."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-install_scriptstorage_script_entry-script_dir-access_permissions",children:"FunctionDef install_script(storage_script_entry, script_dir, access_permissions)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"install_script"}),": The function of install_script is to copy scripts to specific directories and create directories for them if given arguments and copy them there."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 storage_script_entry: A object that contains the script's information, such as the script's path, number, and arguments.\n\xb7 script_dir: The directory where the script will be copied.\n\xb7 access_permissions: The access permissions for the script file."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsxs)(t.p,{children:["The function first creates the script directory if it doesn't exist already using the ",(0,i.jsx)(t.code,{children:"mkdir"})," method. Then it creates the script file name by combining the script number (with leading zeros for a total of 5 digits) and the script's original file name. The script file is then copied to the specified directory using the ",(0,i.jsx)(t.code,{children:"shutil.copyfile"})," method."]}),"\n",(0,i.jsxs)(t.p,{children:["Next, the function sets the access permissions for the script file using the ",(0,i.jsx)(t.code,{children:"os.chmod"})," method. If the ",(0,i.jsx)(t.code,{children:"storage_script_entry"})," object contains arguments, the function creates a new directory for the arguments, creates a file for the arguments, writes the arguments to the file, and closes the file."]}),"\n",(0,i.jsxs)(t.p,{children:["From a functional perspective, this function is called by two other objects in the project: ",(0,i.jsx)(t.code,{children:"filling_cache"})," in ",(0,i.jsx)(t.code,{children:"gpoa/frontend/scripts_applier.py/scripts_applier/"})," and ",(0,i.jsx)(t.code,{children:"filling_cache"})," in ",(0,i.jsx)(t.code,{children:"gpoa/frontend/scripts_applier.py/scripts_applier_user/"}),". In both cases, the function is used to copy and organize scripts in specific directories based on the script's type (STARTUP, SHUTDOWN, LOGON, or LOGOFF) and the user's username."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"storage_script_entry"})," object must contain the correct information for the script, including the script's path, number, and arguments."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"script_dir"})," parameter must be a valid directory path."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"access_permissions"})," parameter must be a valid octal number representing the access permissions for the script file."]}),"\n",(0,i.jsx)(t.li,{children:"The function will create the script directory and argument directory if they do not exist."}),"\n",(0,i.jsx)(t.li,{children:"The function will overwrite existing script files with the same name."}),"\n",(0,i.jsx)(t.li,{children:"The function does not check if the script file is executable or not after setting the access permissions."}),"\n",(0,i.jsx)(t.li,{children:"The function does not check if the argument file is closed properly or not after writing the arguments to the file."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>o});var i=s(6540);const n={},r=i.createContext(n);function c(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);