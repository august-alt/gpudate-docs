"use strict";(self.webpackChunkgpupdate_docs=self.webpackChunkgpupdate_docs||[]).push([[6641],{1247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var i=n(4848),r=n(8453);const s={},c=void 0,o={id:"gpoa/gpt/gpt",title:"gpt",description:"ClassDef FileType",source:"@site/docs/gpoa/gpt/gpt.md",sourceDirName:"gpoa/gpt",slug:"/gpoa/gpt/",permalink:"/docs/gpoa/gpt/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"yandex_browser_applier",permalink:"/docs/gpoa/frontend/yandex_browser_applier"},next:{title:"drives",permalink:"/docs/gpoa/gpt/drives"}},a={},h=[{value:"ClassDef FileType",id:"classdef-filetype",level:2},{value:"FunctionDef get_preftype(path_to_file)",id:"functiondef-get_preftypepath_to_file",level:2},{value:"FunctionDef pref_parsers",id:"functiondef-pref_parsers",level:2},{value:"FunctionDef get_parser(preference_type)",id:"functiondef-get_parserpreference_type",level:2},{value:"FunctionDef pref_mergers",id:"functiondef-pref_mergers",level:2},{value:"FunctionDef get_merger(preference_type)",id:"functiondef-get_mergerpreference_type",level:2},{value:"ClassDef gpt",id:"classdef-gpt",level:2},{value:"FunctionDef <strong>init</strong>(self, gpt_path, sid)",id:"functiondef-initself-gpt_path-sid",level:3},{value:"FunctionDef set_name(self, name)",id:"functiondef-set_nameself-name",level:3},{value:"FunctionDef merge_machine(self)",id:"functiondef-merge_machineself",level:3},{value:"FunctionDef merge_user(self)",id:"functiondef-merge_userself",level:3},{value:"FunctionDef find_dir(search_path, name)",id:"functiondef-find_dirsearch_path-name",level:2},{value:"FunctionDef find_file(search_path, name)",id:"functiondef-find_filesearch_path-name",level:2},{value:"FunctionDef find_preferences(search_path)",id:"functiondef-find_preferencessearch_path",level:2},{value:"FunctionDef find_preffile(search_path, prefname)",id:"functiondef-find_preffilesearch_path-prefname",level:2},{value:"FunctionDef lp2gpt",id:"functiondef-lp2gpt",level:2},{value:"FunctionDef get_local_gpt(sid)",id:"functiondef-get_local_gptsid",level:2}];function l(e){const t={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"classdef-filetype",children:"ClassDef FileType"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"FileType"}),": The ",(0,i.jsx)(t.code,{children:"FileType"})," class is an enumeration type that defines various file types used in the project."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Attributes"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"PREG"}),": A class attribute representing the file type 'registry.pol'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"SHORTCUTS"}),": A class attribute representing the file type 'shortcuts.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"FOLDERS"}),": A class attribute representing the file type 'folders.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"FILES"}),": A class attribute representing the file type 'files.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"DRIVES"}),": A class attribute representing the file type 'drives.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"SCHEDULEDTASKS"}),": A class attribute representing the file type 'scheduledtasks.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"ENVIRONMENTVARIABLES"}),": A class attribute representing the file type 'environmentvariables.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"INIFILES"}),": A class attribute representing the file type 'inifiles.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"SERVICES"}),": A class attribute representing the file type 'services.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"PRINTERS"}),": A class attribute representing the file type 'printers.xml'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"SCRIPTS"}),": A class attribute representing the file type 'scripts.ini'."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"NETWORKSHARES"}),": A class attribute representing the file type 'networkshares.xml'."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"FileType"})," class is an enumeration type that defines various file types used in the project. It is used to map file names to their corresponding file types, which can be used for further processing or merging."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"FileType"})," class is used in the ",(0,i.jsx)(t.code,{children:"get_preftype"})," function to determine the file type of a given file path. It iterates through all the possible file types and checks if the file name matches the value of any of the file types. If a match is found, it returns the corresponding file type."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"FileType"})," class is also used in the ",(0,i.jsx)(t.code,{children:"pref_parsers"})," and ",(0,i.jsx)(t.code,{children:"pref_mergers"})," functions to map file types to their corresponding parser and merger functions. This allows the functions to handle different file types in a generic way."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"FileType"})," class should be used carefully to ensure that the file names match the corresponding file types."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"FileType"})," class should be updated if new file types are added to the project."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"FileType"})," class should be used consistently throughout the project to ensure that all file types are handled correctly."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-get_preftypepath_to_file",children:"FunctionDef get_preftype(path_to_file)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"get_preftype"}),": The function of get_preftype is to determine and return the file type of a given file path."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 path_to_file: A string representing the file path whose file type is to be determined."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe get_preftype function takes a file path as an input and returns the corresponding file type from the FileType enumeration class. It first converts the file name to lowercase for case-insensitive comparison. Then, it iterates through all the possible file types defined in the FileType enumeration class and checks if the file name matches the value of any of the file types. If a match is found, it returns the corresponding file type. If no match is found, it returns None."]}),"\n",(0,i.jsx)(t.p,{children:"The function uses the Path object from the pathlib module to handle file paths and the FileType enumeration class to map file names to their corresponding file types."}),"\n",(0,i.jsx)(t.p,{children:"The get_preftype function is called in the merge_machine and merge_user functions of the gpt.py module to determine the file type of the preference paths before merging them to the registry. This allows the functions to handle different file types in a generic way."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The get_preftype function should be used carefully to ensure that the file names match the corresponding file types."}),"\n",(0,i.jsx)(t.li,{children:"The get_preftype function should be updated if new file types are added to the project."}),"\n",(0,i.jsx)(t.li,{children:"The get_preftype function should be used consistently throughout the project to ensure that all file types are handled correctly."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output Example"}),":\nIf the file path is 'C:\\Windows\\System32\\shortcuts.xml', the function will return:"]}),"\n",(0,i.jsx)(t.p,{children:"SHORTCUTS"}),"\n",(0,i.jsx)(t.p,{children:"If the file path is 'C:\\Windows\\System32\\drives.txt', the function will return:"}),"\n",(0,i.jsx)(t.p,{children:"None"}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-pref_parsers",children:"FunctionDef pref_parsers"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"pref_parsers"}),": The function of pref_parsers is to return a dictionary of file type constants as keys and corresponding file reader functions as values."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": The parameters of this Function.\n\xb7 preference_type: A FileType constant representing the type of preference file to be parsed."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),": The pref_parsers function is a factory function that returns a dictionary of file type constants as keys and corresponding file reader functions as values. It uses a switch-like structure to determine the appropriate file reader function based on the preference_type parameter. The function first initializes an empty dictionary called parsers. It then iterates over the FileType constants using a for loop. For each constant, it checks if it matches the preference_type parameter using an if statement. If there is a match, it adds the constant as a key and the corresponding file reader function as a value to the parsers dictionary. Finally, the function returns the parsers dictionary."]}),"\n",(0,i.jsx)(t.p,{children:"From a functional perspective, the pref_parsers function is called in the gpoa/gpt/gpt.py/parse_preferences function. The parse_preferences function takes a list of preference files and their corresponding file types as input. It iterates over the list using a for loop. For each file, it calls the pref_parsers function with the corresponding file type as the argument. It then calls the returned file reader function with the file path as the argument. The file reader function returns a list of preference entries, which are then added to a master list of preference entries. Finally, the master list of preference entries is returned by the parse_preferences function."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": Points to note about the use of the code"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The pref_parsers function assumes that the FileType constants are defined and available for use."}),"\n",(0,i.jsx)(t.li,{children:"The pref_parsers function is only intended to be called by the parse_preferences function and should not be called directly."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output Example"}),":\nSuppose we have a list of preference files and their corresponding file types as follows:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"preference_files = [\n    ('C:\\\\example\\\\pref1.xml', FileType.FOLDERS),\n    ('C:\\\\example\\\\pref2.xml', FileType.FILES),\n    ('C:\\\\example\\\\pref3.xml', FileType.DRIVES),\n    ('C:\\\\example\\\\pref4.xml', FileType.ENVIRONMENTVARIABLES),\n    ('C:\\\\example\\\\pref5.xml', FileType.INIFILES),\n    ('C:\\\\example\\\\pref6.xml', FileType.SERVICES),\n    ('C:\\\\example\\\\pref7.xml', FileType.PRINTERS),\n    ('C:\\\\example\\\\pref8.xml', FileType.SCRIPTS),\n    ('C:\\\\example\\\\pref9.xml', FileType.NETWORKSHARES),\n]\n"})}),"\n",(0,i.jsx)(t.p,{children:"Calling the parse_preferences function with this list as its parameter would return the following list of preference entries:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"[\n    folderentry('C:\\\\example\\\\folder1'),\n    fileentry('C:\\\\example\\\\file1', 'C', 'D:\\\\example\\\\file1'),\n    driveentry('C:\\\\', 'C', 'D:\\\\'),\n    envvar('VAR1', 'value1', 'U'),\n    inifile('C:\\\\example\\\\config.ini', 'C', 'D:\\\\example\\\\config.ini'),\n    service('MyService', 'C', 'D:\\\\example\\\\MyService.exe'),\n    printer('MyPrinter', 'C', 'D:\\\\example\\\\MyPrinter.inf'),\n    script('MyScript', 'C', 'D:\\\\example\\\\MyScript.bat'),\n    networkshare('MyShare', 'C', 'D:\\\\example\\\\MyShare'),\n    ...\n]\n"})}),"\n",(0,i.jsx)(t.p,{children:"This list contains preference entries for each file type, including folders, files, drives, environment variables, ini files, services, printers, scripts, and network shares.\nRaw code:```\ndef pref_parsers():\nparsers = dict()"}),"\n",(0,i.jsx)(t.p,{children:"for preference_type in FileType:\nif preference_type == FileType.PREG:\nparsers[preference_type] = read_polfile\nelif preference_type == FileType.SHORTCUTS:\nparsers[preference_type] = read_shortcuts\nelif preference_type == FileType.FOLDERS:\nparsers[preference_type] = read_folders\nelif"}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-get_parserpreference_type",children:"FunctionDef get_parser(preference_type)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"get_parser"}),": The function of get_parser is to return a parser function for a given preference type. It is used to parse preference files of different types."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": The parameters of this Function.\n\xb7 preference_type: A constant representing the type of preference file to be parsed."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),": The get_parser function takes a preference_type as an argument and returns a parser function for that type from a dictionary of parsers. The dictionary is created by the pref_parsers function, which is a factory function that returns a dictionary of file type constants as keys and corresponding file reader functions as values. The get_parser function first calls the pref_parsers function to get the dictionary of parsers. It then returns the parser function corresponding to the given preference_type from the dictionary."]}),"\n",(0,i.jsx)(t.p,{children:"From a functional perspective, the get_parser function is called in the merge_machine and merge_user functions in the gpt.py module. These functions merge machine and user settings to storage, respectively. In these functions, the get_parser function is used to parse preference files of different types before merging them to the storage."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": Points to note about the use of the code"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The get_parser function assumes that the pref_parsers function has been called and has initialized the parsers dictionary."}),"\n",(0,i.jsx)(t.li,{children:"The get_parser function is only intended to be called with a valid preference_type constant."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output Example"}),":\nSuppose we have a preference_type constant representing the type of preference file to be parsed."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"preference_type = FileType.FOLDERS\n"})}),"\n",(0,i.jsx)(t.p,{children:"Calling the get_parser function with this preference_type as its parameter would return the following parser function for folders."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"<function read_folders at 0x10f6a9b70>\n"})}),"\n",(0,i.jsx)(t.p,{children:"This parser function can then be used to parse a preference file of folders type."}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-pref_mergers",children:"FunctionDef pref_mergers"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"pref_mergers"}),": The function of pref_mergers is to create and return a dictionary of merger functions for different file types. This dictionary is used to merge preferences of different types in the Group Policy Objects (GPO) management system."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 None: The function does not take any parameters."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe function initializes an empty dictionary called ",(0,i.jsx)(t.code,{children:"mergers"}),". It then populates the dictionary with merger functions for different file types by calling the corresponding functions and storing them as values in the dictionary, using the file type constants (defined in the ",(0,i.jsx)(t.code,{children:"FileType"})," enumeration class) as keys. The merger functions are:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"merge_polfile"})," for the file type ",(0,i.jsx)(t.code,{children:"FileType.PREG"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"merge_shortcuts"})," for the file type ",(0,i.jsx)(t.code,{children:"FileType.SHORTCUTS"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"merge_folders"})," for the file type ",(0,i.jsx)(t.code,{children:"FileType.FOLDERS"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"merge_files"})," for the file type ",(0,i.jsx)(t.code,{children:"FileType.FILES"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"merge_drives"})," for the file type ",(0,i.jsx)(t.code,{children:"FileType.DRIVES"})]}),"\n",(0,i.jsx)(t.li,{}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-get_mergerpreference_type",children:"FunctionDef get_merger(preference_type)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"get_merger"}),": The function of get_merger is to retrieve a specific merger function from a dictionary of merger functions, which is created and returned by the pref_mergers function. This dictionary contains merger functions for different file types in the Group Policy Objects (GPO) management system."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 preference_type: A parameter of preference_type, which is a constant defined in the FileType enumeration class, representing the file type of the preference."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe function calls the pref_mergers function to get a dictionary of merger functions for different file types. It then returns the merger function corresponding to the preference_type parameter from the dictionary."]}),"\n",(0,i.jsx)(t.p,{children:"The get_merger function is used in the merge_machine and merge_user functions of the gpt module to merge preferences of different types in the GPO management system. It is called with a preference_type parameter representing the file type of the preference to be merged. The returned merger function is then used to merge the preference objects of the corresponding file type to the storage."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":\nIt is important to note that the preference_type parameter passed to the get_merger function should be a constant defined in the FileType enumeration class, representing the file type of the preference."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output Example"}),":\nIn the merge_machine function, the get_merger function might be called as follows:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"preference_merger = get_merger(preference_type)\n"})}),"\n",(0,i.jsx)(t.p,{children:"where preference_type is a constant defined in the FileType enumeration class, representing the file type of the preference to be merged. The returned merger function is then used to merge the preference objects of the corresponding file type to the storage."}),"\n",(0,i.jsx)(t.h2,{id:"classdef-gpt",children:"ClassDef gpt"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"gpt"}),": The ",(0,i.jsx)(t.code,{children:"gpt"})," class is used to handle Group Policy Template (GPT) functionalities. It takes ",(0,i.jsx)(t.code,{children:"gpt_path"})," and ",(0,i.jsx)(t.code,{children:"sid"})," as parameters to initialize the object, which are used to set the path of the GPT and the security identifier respectively."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"attributes"}),":\n\xb7 ",(0,i.jsx)(t.code,{children:"path"}),": The path of the GPT.\n\xb7 ",(0,i.jsx)(t.code,{children:"sid"}),": The security identifier.\n\xb7 ",(0,i.jsx)(t.code,{children:"storage"}),": A dictionary-like object that stores the GPT settings.\n\xb7 ",(0,i.jsx)(t.code,{children:"name"}),": The human-readable name of the GPT.\n\xb7 ",(0,i.jsx)(t.code,{children:"guid"}),": The globally unique identifier of the GPT.\n\xb7 ",(0,i.jsx)(t.code,{children:"_machine_path"}),", ",(0,i.jsx)(t.code,{children:"_user_path"}),", ",(0,i.jsx)(t.code,{children:"_scripts_machine_path"}),", ",(0,i.jsx)(t.code,{children:"_scripts_user_path"}),": The paths of the machine, user, machine scripts, and user scripts directories respectively.\n\xb7 ",(0,i.jsx)(t.code,{children:"settings_list"}),": A list of settings that the GPT can handle.\n\xb7 ",(0,i.jsx)(t.code,{children:"settings"}),": A dictionary that stores the machine and user settings."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe ",(0,i.jsx)(t.code,{children:"__init__"})," method initializes the object with the given ",(0,i.jsx)(t.code,{children:"gpt_path"})," and ",(0,i.jsx)(t.code,{children:"sid"}),". It sets the ",(0,i.jsx)(t.code,{children:"path"}),", ",(0,i.jsx)(t.code,{children:"sid"}),", and ",(0,i.jsx)(t.code,{children:"storage"})," attributes, and initializes the ",(0,i.jsx)(t.code,{children:"name"})," attribute as an empty string. The ",(0,i.jsx)(t.code,{children:"guid"})," attribute is set to the last part of the ",(0,i.jsx)(t.code,{children:"path"}),", or 'Local Policy' if the ",(0,i.jsx)(t.code,{children:"path"})," is 'default'. The ",(0,i.jsx)(t.code,{children:"_machine_path"}),", ",(0,i.jsx)(t.code,{children:"_user_path"}),", ",(0,i.jsx)(t.code,{children:"_scripts_machine_path"}),", and ",(0,i.jsx)(t.code,{children:"_scripts_user_path"})," attributes are set using the ",(0,i.jsx)(t.code,{children:"find_dir"})," function. The ",(0,i.jsx)(t.code,{children:"settings_list"})," attribute is a list of settings that the GPT can handle, and the ",(0,i.jsx)(t.code,{children:"settings"})," attribute is a dictionary that stores the machine and user settings."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"set_name"})," method sets the ",(0,i.jsx)(t.code,{children:"name"})," attribute to the given ",(0,i.jsx)(t.code,{children:"name"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"merge_machine"})," method merges the machine settings to the ",(0,i.jsx)(t.code,{children:"storage"})," attribute. It first checks if the machine policy file exists, and if it does, it merges it to the registry using the ",(0,i.jsx)(t.code,{children:"merge_polfile"})," function. Then, it iterates over the machine settings and merges them to the registry if they exist."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"merge_user"})," method is similar to the ",(0,i.jsx)(t.code,{children:"merge_machine"})," method, but it merges the user settings to the ",(0,i.jsx)(t.code,{children:"storage"})," attribute instead."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"find_dir"})," and ",(0,i.jsx)(t.code,{children:"find_preffile"})," functions are not defined in the code snippet, so it is assumed that they are defined elsewhere in the project."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"registry_factory"}),", ",(0,i.jsx)(t.code,{children:"util.preg"}),", ",(0,i.jsx)(t.code,{children:"get_preftype"}),", ",(0,i.jsx)(t.code,{children:"get_parser"}),", and ",(0,i.jsx)(t.code,{children:"get_merger"})," functions are also not defined in the code snippet, so it is assumed that they are defined elsewhere in the project."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"log"})," function is used to log messages, and it is assumed that it is defined elsewhere in the project."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"gpt_path"})," parameter should be a valid path to a GPT, and the ",(0,i.jsx)(t.code,{children:"sid"})," parameter should be a valid security identifier."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"merge_machine"})," and ",(0,i.jsx)(t.code,{children:"merge_user"})," methods modify the ",(0,i.jsx)(t.code,{children:"storage"})," attribute, so any changes made to it will be reflected in the GPT."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"merge_machine"})," and ",(0,i.jsx)(t.code,{children:"merge_user"})," methods can raise exceptions if there are any errors while merging the settings to the registry."]}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"functiondef-initself-gpt_path-sid",children:["FunctionDef ",(0,i.jsx)(t.strong,{children:"init"}),"(self, gpt_path, sid)"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})}),": The function of ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})})," is to initialize an instance of the gpt class with the specified path and sid."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 ",(0,i.jsx)(t.code,{children:"gpt_path"}),": A string representing the path to the Group Policy Template (GPT) folder.\n\xb7 ",(0,i.jsx)(t.code,{children:"sid"}),": A string representing the security identifier (SID) of the user or computer for which the GPT is being created."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})})," function initializes an instance of the gpt class with the specified path and sid. It first sets the path and sid attributes of the instance to the input values. It then creates a storage object using the registry_factory function, passing in the string 'registry' as the name parameter. This creates a SQLAlchemy session and queries the database to get the necessary information about the domain, machine name, and machine SID."]}),"\n",(0,i.jsx)(t.p,{children:"Next, the function sets the name attribute of the instance to an empty string. It then sets the guid attribute of the instance to the last part of the path, after the final slash. If the guid is 'default', it sets it to 'Local Policy'."}),"\n",(0,i.jsx)(t.p,{children:"The function then calls the find_dir function four times to find the machine path, user path, scripts machine path, and scripts user path. It does this by calling find_dir on the path, passing in the string 'Machine', 'User', 'Scripts/Machine', and 'Scripts/User', respectively. These paths are used to access the various settings and files in the GPT."}),"\n",(0,i.jsx)(t.p,{children:"The function then creates two empty dictionaries in the settings attribute of the instance, one for machine settings and one for user settings. It then sets the regpol attribute of both the machine and user settings to the result of calling the find_file function on the machine path and user path, respectively, passing in the string 'registry.pol'."}),"\n",(0,i.jsx)(t.p,{children:"Finally, the function iterates over the settings_list attribute of the instance, which contains a list of strings representing various settings. For each setting, it calls the find_preffile function, passing in the machine path and user path, and the current setting. It then sets the corresponding attribute of the machine and user settings dictionaries to the result of the find_preffile function."}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.strong,{children:"init"})})," function is called when a new instance of the gpt class is created. It initializes the instance with the necessary attributes and storage objects, and finds the various paths and files needed to access the settings and policies in the GPT."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":\nNone."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-set_nameself-name",children:"FunctionDef set_name(self, name)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"set_name"}),"\uff1aThe function of set_name is to set a human-readable name for the Group Policy Template (GPT) object."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),"\uff1a\n\xb7 name: A string representing the display name of the GPO."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),"\uff1a\nThe set_name function is a simple method that sets the name attribute of the GPT object to the input string. It is used to provide a human-readable name for the GPT, which can be useful for identification and debugging purposes."]}),"\n",(0,i.jsx)(t.p,{children:"In the provided code snippets, the set_name function is called in two different objects: gpoa/backend/samba_backend.py/samba_backend/_get_gpts and gpoa/gpt/gpt.py/get_local_gpt."}),"\n",(0,i.jsx)(t.p,{children:"In the samba_backend/_get_gpts function, set_name is called after creating a new GPT object using the gpt module. It sets the name of the GPT object to the display name of the Group Policy Object (GPO) fetched from the Samba backend. This allows for easy identification of the GPO in the GPT object."}),"\n",(0,i.jsx)(t.p,{children:"In the get_local_gpt function, set_name is called after creating a new GPT object for the local policy. It sets the name of the GPT object to 'Local Policy', indicating that this GPT object represents the local policy on the system."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),"\uff1a"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The set_name function should only be called after creating a new GPT object. Calling it on a non-existent or invalid GPT object may result in unexpected behavior."}),"\n",(0,i.jsx)(t.li,{children:"The input string for the name parameter should be a valid display name, preferably without any special characters that may cause issues during processing or display."}),"\n",(0,i.jsx)(t.li,{children:"It is essential to ensure that the name provided is unique for each GPT object to avoid confusion and potential data corruption."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-merge_machineself",children:"FunctionDef merge_machine(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"merge_machine"}),": The function of merge_machine is to merge machine settings to storage."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": This function does not take any parameters."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsx)(t.p,{children:"The merge_machine function is defined in the gpoa/gpt/gpt.py module and is responsible for merging machine settings to storage. It is primarily called by the retrieve_and_store function in the nodomain_backend and samba_backend modules of the gpoa/backend directory."}),"\n",(0,i.jsx)(t.p,{children:"The function begins by trying to merge machine policies to the registry if the 'regpol' key is present in the machine settings dictionary. It does this by calling the merge_polfile function from the gpoa/util/preg.py module, passing in the 'regpol' value as the preg parameter, and the name attribute of the instance as the policy_name parameter."}),"\n",(0,i.jsx)(t.p,{children:"Next, the function iterates over the items in the machine settings dictionary, excluding the 'regpol' key. For each item, it gets the preference_type using the get_preftype function, passing in the preference_path value as the path_to_file parameter. It then gets the parser function using the get_parser function, passing in the preference_type constant as the preference_type parameter. The parser function is then called with the preference_path value as the parameter, and the result is stored in the preference_objects variable."}),"\n",(0,i.jsx)(t.p,{children:"Finally, the function gets the merger function using the get_merger function, passing in the preference_type constant as the preference_type parameter. The merger function is then called with the storage, sid, preference_objects, and name attributes of the instance as parameters."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Relationship with its callers in the project"}),":"]}),"\n",(0,i.jsx)(t.p,{children:"The merge_machine function is primarily called by the retrieve_and_store function in the nodomain_backend and samba_backend modules of the gpoa/backend directory. In the nodomain_backend module, the function is called after wiping the HKLM and machine_sid user settings in the storage object. In the samba_backend module, the function is called after getting the machine GPTs and wiping the HKLM and machine_sid user settings in the storage object."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The merge_machine function assumes that the get_preftype, get_parser, and get_merger functions have been called and have initialized the necessary variables."}),"\n",(0,i.jsx)(t.li,{children:"The merge_machine function is only intended to be called with a valid machine settings dictionary."}),"\n",(0,i.jsx)(t.li,{children:"The merge_machine function should be used carefully to ensure that the machine settings are merged correctly to the storage object."}),"\n",(0,i.jsx)(t.li,{children:"The merge_machine function should be updated if new preference types are added to the project."}),"\n",(0,i.jsx)(t.li,{children:"The merge_machine function should be used consistently throughout the project to ensure that all machine settings are merged correctly to the storage object."}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"functiondef-merge_userself",children:"FunctionDef merge_user(self)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"merge_user"}),": The function of merge_user is to merge user settings to storage."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": The parameters of this Function are as follows:\n\xb7 self: The object that calls this function."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-find_dirsearch_path-name",children:"FunctionDef find_dir(search_path, name)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"find_dir"}),": The function of find_dir is to attempt a case-insensitive search of a directory within a specified search path."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),"\n\xb7 ",(0,i.jsx)(t.code,{children:"search_path"}),": A string representing the path to get the file list from. This path is used to start the search for the directory.\n\xb7 ",(0,i.jsx)(t.code,{children:"name"}),": A string representing the name of the directory to search for. The search is case-insensitive."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),"\nThe function begins by checking if the ",(0,i.jsx)(t.code,{children:"search_path"})," is empty or not. If it is empty, the function returns ",(0,i.jsx)(t.code,{children:"None"}),". This is to ensure that the function does not attempt to search in an invalid path."]}),"\n",(0,i.jsxs)(t.p,{children:["The function then lists all the entries in the ",(0,i.jsx)(t.code,{children:"search_path"})," using ",(0,i.jsx)(t.code,{children:"os.listdir()"}),". It then iterates over each entry in the list and checks if it is a directory and if its name matches the ",(0,i.jsx)(t.code,{children:"name"})," parameter (case-insensitively). If a match is found, the function returns the path of the directory."]}),"\n",(0,i.jsx)(t.p,{children:"If an exception occurs during the iteration, the function ignores it and continues with the next entry. This is to ensure that the function does not crash due to a single error."}),"\n",(0,i.jsxs)(t.p,{children:["If no match is found, the function returns ",(0,i.jsx)(t.code,{children:"None"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The function is called in the ",(0,i.jsx)(t.code,{children:"__init__"})," method of the ",(0,i.jsx)(t.code,{children:"gpt"})," class in the same module. It is used to find the machine and user paths, as well as the scripts machine and user paths. The function is also called in the ",(0,i.jsx)(t.code,{children:"find_preferences"})," and ",(0,i.jsx)(t.code,{children:"find_preffile"})," functions in the same module."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),"\nThe function performs a case-insensitive search of the directory name. Therefore, it is possible that the function may return a directory that has a different case than the ",(0,i.jsx)(t.code,{children:"name"})," parameter."]}),"\n",(0,i.jsxs)(t.p,{children:["The function returns ",(0,i.jsx)(t.code,{children:"None"})," if no match is found. Therefore, it is important to check the return value before using it."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Output Example"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-makefile",children:"search_path = '/path/to/search'\nname = 'dir_name'\n\nresult = find_dir(search_path, name)\n\nif result is not None:\n    print('Directory found:', result)\nelse:\n    print('Directory not found')\n"})}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-find_filesearch_path-name",children:"FunctionDef find_file(search_path, name)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"find_file"}),": The function of find_file is to search for a file in a specified directory in a case-insensitive manner."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 search_path: A string representing the path of the directory to be searched.\n\xb7 name: A string representing the name of the file to be searched."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe function first checks if the search path and name parameters are not empty. If either of them is empty, the function returns None. It then tries to list the contents of the search path using os.listdir(). For each entry in the file list, it checks if the entry is a file and if its name (in lowercase) matches the specified name (in lowercase). If a match is found, the function returns the absolute path of the file. If an exception occurs during the file search, it is caught and ignored, and the function continues with the next entry. If no match is found after searching all entries, the function returns None."]}),"\n",(0,i.jsxs)(t.p,{children:["The function is called in the ",(0,i.jsx)(t.strong,{children:"init"}),"() method of the gpt class to find the path of the registry.pol file and the scripts.ini file for both machine and user settings. It is also called in the find_preffile() function to find the path of the preference file."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":\n\xb7 The function is case-insensitive, meaning it will match files with names that differ only in case.\n\xb7 If an exception occurs during the file search, the function will ignore it and continue with the next entry.\n\xb7 If the search path or name parameter is empty, the function will return None."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output Example"}),":\nIf the search path is '/path/to/directory' and the name is 'file.txt', the function may return '/path/to/directory/file.txt' if a file with that name exists in the directory. If no such file exists, the function will return None."]}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-find_preferencessearch_path",children:"FunctionDef find_preferences(search_path)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"find_preferences"}),": The function of find_preferences is to find the 'Preferences' directory within a specified search path."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),"\n\xb7 ",(0,i.jsx)(t.code,{children:"search_path"}),": A string representing the path to get the file list from. This path is used to start the search for the 'Preferences' directory."]}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-find_preffilesearch_path-prefname",children:"FunctionDef find_preffile(search_path, prefname)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"find_preffile"}),": The function of find_preffile is to locate a file with a path in the format 'Preferences/prefname/prefname.xml' within a specified search path."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),"\n\xb7 ",(0,i.jsx)(t.code,{children:"search_path"}),": A string representing the path to start the search for the 'Preferences' directory.\n\xb7 ",(0,i.jsx)(t.code,{children:"prefname"}),": A string representing the name of the preference directory to search for."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),"\nThe function begins by calling the ",(0,i.jsx)(t.code,{children:"find_preferences"})," function, which attempts to find the 'Preferences' directory within the provided ",(0,i.jsx)(t.code,{children:"search_path"}),". If the 'Preferences' directory is not found, the function returns ",(0,i.jsx)(t.code,{children:"None"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["If the 'Preferences' directory is found, the function then calls the ",(0,i.jsx)(t.code,{children:"find_dir"})," function, passing in the 'Preferences' directory and the ",(0,i.jsx)(t.code,{children:"prefname"})," parameter to search for the preference directory. The ",(0,i.jsx)(t.code,{children:"find_dir"})," function returns the path of the preference directory if it is found, or ",(0,i.jsx)(t.code,{children:"None"})," otherwise."]}),"\n",(0,i.jsxs)(t.p,{children:["If the preference directory is found, the function then constructs the file name by concatenating the ",(0,i.jsx)(t.code,{children:"prefname"})," parameter with the string '.xml'. It then calls the ",(0,i.jsx)(t.code,{children:"find_file"})," function, passing in the preference directory and the constructed file name to search for the preference file. The ",(0,i.jsx)(t.code,{children:"find_file"})," function returns the path of the preference file if it is found, or ",(0,i.jsx)(t.code,{children:"None"})," otherwise."]}),"\n",(0,i.jsxs)(t.p,{children:["The function returns the path of the preference file if it is found, or ",(0,i.jsx)(t.code,{children:"None"})," otherwise."]}),"\n",(0,i.jsxs)(t.p,{children:["The function is called in the ",(0,i.jsx)(t.code,{children:"__init__"})," method of the ",(0,i.jsx)(t.code,{children:"gpt"})," class in the same module to find the paths of various preference files for both machine and user settings. It is used to find the paths of preference files for settings such as shortcuts, drives, environment variables, printers, folders, files, ini files, services, scheduled tasks, scripts, and network shares."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),"\n\xb7 The function performs a case-insensitive search of the preference directory name and preference file name. Therefore, it is possible that the function may return a preference directory or preference file that has a different case than the ",(0,i.jsx)(t.code,{children:"prefname"})," parameter.\n\xb7 The function returns ",(0,i.jsx)(t.code,{children:"None"})," if no match is found. Therefore, it is important to check the return value before using it."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Output Example"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-makefile",children:"search_path = '/path/to/Preferences'\nprefname = 'shortcuts'\n\nresult = find_preffile(search_path, prefname)\n\nif result is not None:\n    print('Preference file found:', result)\nelse:\n    print('Preference file not found')\n"})}),"\n",(0,i.jsx)(t.p,{children:"This code will search for a preference file with the name 'shortcuts' and the extension '.xml' in the 'Preferences' directory located at '/path/to/Preferences'. If the preference file is found, the code will print the path of the preference file. If the preference file is not found, the code will print 'Preference file not found'."}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-lp2gpt",children:"FunctionDef lp2gpt"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"lp2gpt"}),": The function of lp2gpt is to convert local-policy to full-featured GPT."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),": This function does not take any parameters."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe lp2gpt function begins by defining the path of the local policy file (lppath) using the local_policy_path function, which returns the pathlib.Path object pointing to the Local Policy template directory."]}),"\n",(0,i.jsx)(t.p,{children:"Next, it creates an instance of the GPPolParser class and assigns it to the polparser variable. It then loads the local policy file using the load_preg function, which checks the file extension of the provided file path and loads the corresponding object. It returns a preg object if the file extension is .xml and a pol object if the file extension is not .xml. The loaded local policy file is assigned to the polfile variable."}),"\n",(0,i.jsx)(t.p,{children:"After loading the local policy file, the lp2gpt function creates the target default policy directory if missing using the os.makedirs function. It then writes the PReg by calling the write_binary function of the polparser object and passing the destination path as an argument."}),"\n",(0,i.jsx)(t.p,{children:"The lp2gpt function is called by the get_local_gpt function in the gpoa/gpt/gpt.py module to convert the default policy to GPT and create an object out of it."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The lp2gpt function assumes that the local policy file exists and is accessible."}),"\n",(0,i.jsx)(t.li,{children:"The lp2gpt function creates the target default policy directory if it does not exist."}),"\n",(0,i.jsx)(t.li,{children:"The lp2gpt function writes the PReg to the target default policy directory using the write_binary function of the polparser object."}),"\n",(0,i.jsx)(t.li,{children:"The lp2gpt function does not return any value. Instead, it modifies the target default policy directory by writing the PReg to it."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"functiondef-get_local_gptsid",children:"FunctionDef get_local_gpt(sid)"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"get_local_gpt"}),": The function of get_local_gpt is to convert the default policy to GPT (Group Policy Template) and create an object out of it, with the name set to 'Local Policy'."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"parameters"}),":\n\xb7 sid: A string representing the security identifier (SID) of the machine or user."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Code Description"}),":\nThe get_local_gpt function begins by logging a message with the code 'D25' to indicate the start of the function execution. It then calls the lp2gpt function to convert the default policy to GPT and create the target default policy directory if missing."]}),"\n",(0,i.jsx)(t.p,{children:"After converting the default policy to GPT, the function creates a new GPT object for the local policy by calling the gpt class with the local policy directory path and the input SID as parameters. It then sets the name of the GPT object to 'Local Policy' by calling the set_name function."}),"\n",(0,i.jsx)(t.p,{children:"The get_local_gpt function is called in two different objects: gpoa/backend/samba_backend.py/samba_backend/_get_gpts and gpoa/gpt/gpt.py/retrieve_and_store."}),"\n",(0,i.jsx)(t.p,{children:"In the samba_backend/_get_gpts function, get_local_gpt is called to retrieve the local policy GPT object for the given SID. It sets the name of the GPT object to 'Local Policy' and appends it to the list of GPT objects returned by the function."}),"\n",(0,i.jsx)(t.p,{children:"In the retrieve_and_store function, get_local_gpt is called to retrieve the local policy GPT object for the machine SID. It then merges the machine and user settings of the local policy GPT object to the storage object using the merge_machine and merge_user functions."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The get_local_gpt function assumes that the local policy file exists and is accessible."}),"\n",(0,i.jsx)(t.li,{children:"The get_local_gpt function creates a new GPT object for the local policy and sets its name to 'Local Policy'."}),"\n",(0,i.jsx)(t.li,{children:"The get_local_gpt function is called in the samba_backend/_get_gpts function to retrieve the local policy GPT object for the given SID and in the retrieve_and_store function to merge the local policy settings to the storage object."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output Example"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"gpt_obj = get_local_gpt('S-1-5-18')\nprint(gpt_obj.name)  # Output: Local Policy\n"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>o});var i=n(6540);const r={},s=i.createContext(r);function c(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);