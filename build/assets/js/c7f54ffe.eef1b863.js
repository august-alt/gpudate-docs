"use strict";(self.webpackChunkgpupdate_docs=self.webpackChunkgpupdate_docs||[]).push([[5195],{7748:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var i=t(4848),o=t(8453);const s={},r=void 0,c={id:"gpoa/util/gpoa_ini_parsing",title:"gpoa_ini_parsing",description:"ClassDef GpoaConfigObj",source:"@site/docs/gpoa/util/gpoa_ini_parsing.md",sourceDirName:"gpoa/util",slug:"/gpoa/util/gpoa_ini_parsing",permalink:"/docs/gpoa/util/gpoa_ini_parsing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"exceptions",permalink:"/docs/gpoa/util/exceptions"},next:{title:"kerberos",permalink:"/docs/gpoa/util/kerberos"}},a={},d=[{value:"ClassDef GpoaConfigObj",id:"classdef-gpoaconfigobj",level:2},{value:"FunctionDef _parse(self, infile)",id:"functiondef-_parseself-infile",level:3},{value:"FunctionDef write(self, outfile, section)",id:"functiondef-writeself-outfile-section",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"classdef-gpoaconfigobj",children:"ClassDef GpoaConfigObj"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"GpoaConfigObj"}),": The function of GpoaConfigObj is to parse and process configuration files in the .ini format, providing methods to read, modify, and write configuration data."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"attributes"}),":\n\xb7 ",(0,i.jsx)(n.code,{children:"infile"}),": A string representing the content of the configuration file.\n\xb7 ",(0,i.jsx)(n.code,{children:"indent_type"}),": A string indicating the type of indentation used in the configuration file.\n\xb7 ",(0,i.jsx)(n.code,{children:"initial_comment"}),": A list of strings containing comments at the beginning of the configuration file.\n\xb7 ",(0,i.jsx)(n.code,{children:"final_comment"}),": A list of strings containing comments at the end of the configuration file.\n\xb7 ",(0,i.jsx)(n.code,{children:"_sectionmarker"}),": A compiled regular expression used to match section markers in the configuration file.\n\xb7 ",(0,i.jsx)(n.code,{children:"_valueexp"}),": A compiled regular expression used to match key-value pairs in the configuration file.\n\xb7 ",(0,i.jsx)(n.code,{children:"COMMENT_MARKERS"}),": A tuple containing comment markers ('#', ';') used in the configuration file."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Code Description"}),":\nGpoaConfigObj is a class that extends the ConfigObj class to provide additional functionality for handling .ini format configuration files. The class has several attributes, including ",(0,i.jsx)(n.code,{children:"infile"}),", ",(0,i.jsx)(n.code,{children:"indent_type"}),", ",(0,i.jsx)(n.code,{children:"initial_comment"}),", ",(0,i.jsx)(n.code,{children:"final_comment"}),", ",(0,i.jsx)(n.code,{children:"_sectionmarker"}),", ",(0,i.jsx)(n.code,{children:"_valueexp"}),", and ",(0,i.jsx)(n.code,{children:"COMMENT_MARKERS"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"_sectionmarker"})," and ",(0,i.jsx)(n.code,{children:"_valueexp"})," attributes are compiled regular expressions used to match section markers and key-value pairs, respectively. The ",(0,i.jsx)(n.code,{children:"COMMENT_MARKERS"})," attribute is a tuple containing comment markers used in the configuration file."]}),"\n",(0,i.jsxs)(n.p,{children:["The class has several methods, including ",(0,i.jsx)(n.code,{children:"_handle_comment"}),", ",(0,i.jsx)(n.code,{children:"_parse"}),", and ",(0,i.jsx)(n.code,{children:"write"}),". The ",(0,i.jsx)(n.code,{children:"_handle_comment"})," method is used to handle comments in the configuration file. The ",(0,i.jsx)(n.code,{children:"_parse"})," method is used to parse the configuration file and populate the ",(0,i.jsx)(n.code,{children:"config"})," attribute with the parsed data. The ",(0,i.jsx)(n.code,{children:"write"})," method is used to write the configuration data to a file."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"_parse"})," method uses the ",(0,i.jsx)(n.code,{children:"_sectionmarker"})," and ",(0,i.jsx)(n.code,{children:"_valueexp"})," attributes to match section markers and key-value pairs, respectively. The method iterates through each line in the configuration file and uses the regular expressions to match section markers and key-value pairs. If a section marker is matched, the method creates a new Section object and adds it to the parent object. If a key-value pair is matched, the method adds it to the current Section object."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"write"})," method is used to write the configuration data to a file. The method takes an optional ",(0,i.jsx)(n.code,{children:"outfile"})," parameter, which is the file object to write to. If ",(0,i.jsx)(n.code,{children:"outfile"})," is not provided, the method writes to a string. The method iterates through each entry in the configuration data and writes it to the file. If the entry is a Section object, the method recursively calls itself to write the nested Section objects."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"unrepr"})," parameter in the constructor is used to control whether or not to use string representations for list values. If set to ",(0,i.jsx)(n.code,{children:"True"}),", list values will be converted to strings."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"_handle_error"})," method is used to handle errors during parsing. The method takes several parameters, including ",(0,i.jsx)(n.code,{children:"msg"}),", ",(0,i.jsx)(n.code,{children:"error_type"}),", ",(0,i.jsx)(n.code,{children:"infile"}),", and ",(0,i.jsx)(n.code,{children:"cur_index"}),". The ",(0,i.jsx)(n.code,{children:"msg"})," parameter is the error message, ",(0,i.jsx)(n.code,{children:"error_type"})," is the type of error, ",(0,i.jsx)(n.code,{children:"infile"})," is the configuration file content, and ",(0,i.jsx)(n.code,{children:"cur_index"})," is the current index in the configuration file."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output Example"}),":\nSuppose we have the following .ini format configuration file:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-makefile",children:"; This is a comment\n[section1]\nkey1 = value1\nkey2 = value2\n\n[section2]\nkey3 = value3\nkey4 = value4\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can create a GpoaConfigObj object and parse the configuration file as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import os\nfrom gpoa.util.gpoa_ini_parsing import GpoaConfigObj\n\nini_file = 'config.ini'\nconfig = GpoaConfigObj(ini_file)\nprint(config['section1']['key1'])  # Output: value1\nprint(config['section2']['key3'])  # Output: value3\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can also modify the configuration data and write it back to the file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"config['section1']['key1'] = 'new_value1'\nconfig['section2']['key3'] = 'new_value3'\nconfig.write()\n"})}),"\n",(0,i.jsx)(n.p,{children:"The modified configuration file will look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-makefile",children:"; This is a comment\n[section1]\nkey1 = new_value1\nkey2\n### FunctionDef _handle_comment(self, comment)\n **_handle\\_comment**: The function of `_handle_comment` is to process and format a given comment string based on certain conditions.\n\n**parameters**:\n\xb7 `self`: The instance of the class `GpoaConfigObj`\n\xb7 `comment`: A string representing the comment to be processed\n\n**Code Description**:\nThe function first checks if the `comment` parameter is empty or not. If it is empty, the function returns an empty string.\n\nNext, it determines the starting indentation `start` for the comment based on the object's `indent_type` attribute. If the `comment` does not start with any of the comment markers specified in the `COMMENT_MARKERS` attribute, it adds the indentation and the default comment marker '# ' to the `start` variable.\n\nFinally, it returns the processed `start` variable along with the stripped `comment` string.\n\nThe `_handle_comment` function is called in the `write` method of the `GpoaConfigObj` class. In the `write` method, the function is used to format and write the comments associated with each entry in the configuration object.\n\nThe `_handle_comment` function ensures that the comments are properly formatted and indented in the output file, making it easier to read and understand the configuration data.\n\n**Note**:\n\n* The `_handle_comment` function assumes that the `COMMENT_MARKERS` attribute of the `GpoaConfigObj` class is a tuple containing valid comment markers.\n* The function does not handle any error cases, such as invalid comment markers or non-string inputs.\n\n**Output Example**:\nGiven the following input:\n```python\nCOMMENT_MARKERS = ('#', ';')\nindent_type = '  '\ncomment = '! This is a comment'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"_handle_comment"})," function would return:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"'  # ! This is a comment'\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"functiondef-_parseself-infile",children:"FunctionDef _parse(self, infile)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"_parse"}),": The function of ",(0,i.jsx)(n.code,{children:"_parse"})," is to parse the configuration file and populate the ",(0,i.jsx)(n.code,{children:"GpoaConfigObj"})," object with the corresponding key-value pairs and sections."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"parameters"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["\xb7 ",(0,i.jsx)(n.code,{children:"self"}),": The instance of the ",(0,i.jsx)(n.code,{children:"GpoaConfigObj"})," class."]}),"\n",(0,i.jsxs)(n.p,{children:["\xb7 ",(0,i.jsx)(n.code,{children:"infile"}),": A file object containing the configuration file to be parsed."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Code Description"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["The method starts by initializing several variables, such as ",(0,i.jsx)(n.code,{children:"temp_list_values"}),", ",(0,i.jsx)(n.code,{children:"comment_list"}),", ",(0,i.jsx)(n.code,{children:"done_start"}),", ",(0,i.jsx)(n.code,{children:"this_section"}),", ",(0,i.jsx)(n.code,{children:"maxline"}),", ",(0,i.jsx)(n.code,{children:"cur_index"}),", ",(0,i.jsx)(n.code,{children:"reset_comment"}),", and ",(0,i.jsx)(n.code,{children:"comment_markers"}),". These variables are used throughout the method to keep track of the current section, line, and comment state."]}),"\n",(0,i.jsxs)(n.p,{children:["The method then enters a while loop, which iterates over each line in the configuration file. If the current line is a comment, it is added to the ",(0,i.jsx)(n.code,{children:"comment_list"})," and the loop continues to the next iteration. If the current line is not a comment, the method checks if it is a section marker. If it is, the method creates a new section object and adds it to the parent section. If the current line is not a section marker, the method assumes it is a valid ",(0,i.jsx)(n.code,{children:"key = value"})," line and extracts the key and value. If the value is multiline, the method extracts the value and any inline comments. If the value is not multiline, the method extracts the value and any inline comments. The method then checks if the key already exists in the current section. If it does, the method raises a ",(0,i.jsx)(n.code,{children:"DuplicateError"}),". If it does not, the method adds the key-value pair to the current section and continues to the next iteration."]}),"\n",(0,i.jsxs)(n.p,{children:["After the while loop, the method sets the ",(0,i.jsx)(n.code,{children:"indent_type"})," attribute if it has not been set. The method then checks if there are any initial or final comments and sets the corresponding attributes. Finally, the method restores the ",(0,i.jsx)(n.code,{children:"list_values"})," attribute to its original value."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The method assumes that the configuration file is correctly formatted and does not contain any syntax errors. If the configuration file contains syntax errors, the method will raise a ",(0,i.jsx)(n.code,{children:"ParseError"}),", ",(0,i.jsx)(n.code,{children:"NestingError"}),", or ",(0,i.jsx)(n.code,{children:"DuplicateError"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The method supports both single-line and multiline values. Multiline values are indicated by triple quotes (",(0,i.jsx)(n.code,{children:'"""'})," or ",(0,i.jsx)(n.code,{children:"'''"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["The method supports inline comments, which are indicated by a ",(0,i.jsx)(n.code,{children:"#"})," symbol at the beginning of the line."]}),"\n",(0,i.jsxs)(n.li,{children:["The method supports both indentation-based and non-indentation-based configuration files. If the configuration file uses indentation, the method will automatically detect the indentation type and use it to parse the file. If the configuration file does not use indentation, the method will set the ",(0,i.jsx)(n.code,{children:"indent_type"})," attribute to an empty string."]}),"\n",(0,i.jsx)(n.li,{children:"The method supports both quoted and unquoted keys and values. Quoted keys and values must be enclosed in single or double quotes. Unquoted keys and values must not contain any spaces or special characters."}),"\n",(0,i.jsx)(n.li,{children:"The method supports nested sections. Nested sections are indicated by a section marker that is nested inside another section."}),"\n",(0,i.jsx)(n.li,{children:"The method supports both ordered and unordered sections. Ordered sections are indicated by a section marker that contains a number. Unordered sections are indicated by a section marker that does not contain a number."}),"\n",(0,i.jsxs)(n.li,{children:["The method supports both unrepr and repred values. Unrepr values are not parsed by the Python ",(0,i.jsx)(n.code,{children:"repr"})," function, while repred values are parsed by the Python ",(0,i.jsx)(n.code,{children:"repr"})," function. By default, the method supports unrepr values. If the ",(0,i.jsx)(n.code,{children:"unrepr"})," attribute is set to ",(0,i.jsx)(n.code,{children:"True"}),", the method will parse repred values instead of unrepr values."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"functiondef-writeself-outfile-section",children:"FunctionDef write(self, outfile, section)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"write"}),": The function of write is to generate a formatted string representation of the configuration object and write it to a file."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"parameters"}),":\n\xb7 ",(0,i.jsx)(n.code,{children:"self"}),": The instance of the class ",(0,i.jsx)(n.code,{children:"GpoaConfigObj"}),"\n\xb7 ",(0,i.jsx)(n.code,{children:"outfile=None"}),": The file-like object to write the configuration to. If ",(0,i.jsx)(n.code,{children:"None"}),", the function returns the formatted string representation instead.\n\xb7 ",(0,i.jsx)(n.code,{children:"section=None"}),": The section of the configuration object to write. If ",(0,i.jsx)(n.code,{children:"None"}),", the entire configuration object is written."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Code Description"}),":\nThe ",(0,i.jsx)(n.code,{children:"write"})," function first initializes an empty list ",(0,i.jsx)(n.code,{children:"out"})," to store the formatted lines of the configuration object. It then checks if the ",(0,i.jsx)(n.code,{children:"indent_type"})," attribute of the object is set. If not, it sets it to the default indent type."]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"section"})," parameter is ",(0,i.jsx)(n.code,{children:"None"}),", the function writes the initial comment of the configuration object to ",(0,i.jsx)(n.code,{children:"out"}),". It then iterates over all entries in the object (scalars and sections) and writes them to ",(0,i.jsx)(n.code,{children:"out"}),". If an entry is a default value, it is skipped. For each entry, its comments and inline comments are written first, followed by the entry itself. If the entry is a section, the function calls itself recursively to write the nested section."]}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"section"})," parameter is not ",(0,i.jsx)(n.code,{children:"None"}),", only the specified section is written to ",(0,i.jsx)(n.code,{children:"out"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["After all entries have been written to ",(0,i.jsx)(n.code,{children:"out"}),", the function writes the final comment of the configuration object to ",(0,i.jsx)(n.code,{children:"out"})," (if the ",(0,i.jsx)(n.code,{children:"section"})," parameter is the configuration object itself)."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"outfile"})," is ",(0,i.jsx)(n.code,{children:"None"}),", the function returns the formatted string representation in ",(0,i.jsx)(n.code,{children:"out"}),". Otherwise, it joins the lines in ",(0,i.jsx)(n.code,{children:"out"})," with the correct newline character and writes the result to ",(0,i.jsx)(n.code,{children:"outfile"}),". If the ",(0,i.jsx)(n.code,{children:"filename"})," attribute of the object is not set, the function writes to ",(0,i.jsx)(n.code,{children:"outfile"}),". Otherwise, it writes to a new file with the name specified in the ",(0,i.jsx)(n.code,{children:"filename"})," attribute."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"write"})," function is called in the ",(0,i.jsx)(n.code,{children:"_create_action"})," and ",(0,i.jsx)(n.code,{children:"_delete_action"})," methods of the ",(0,i.jsx)(n.code,{children:"Ini_file"})," class in the ",(0,i.jsx)(n.code,{children:"ini_file.py"})," module. In ",(0,i.jsx)(n.code,{children:"_create_action"}),", the function is used to write the configuration object to a file after a new key-value pair has been added. In ",(0,i.jsx)(n.code,{children:"_delete_action"}),", the function is used to write the configuration object to a file after a key-value pair has been deleted."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"write"})," function ensures that the configuration object is properly formatted and written to a file, making it easy to read and understand the configuration data."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"write"})," function assumes that the ",(0,i.jsx)(n.code,{children:"COMMENT_MARKERS"})," attribute of the ",(0,i.jsx)(n.code,{children:"GpoaConfigObj"})," class is a tuple containing valid comment markers."]}),"\n",(0,i.jsx)(n.li,{children:"The function does not handle any error cases, such as invalid file objects or non-string inputs."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output Example"}),":\nGiven the following input:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"config = GpoaConfigObj()\nconfig['section1'] = {'key1': 'value1', 'key2': 'value2'}\nconfig['section2'] = {'key3': 'value3', 'key4': 'value4'}\nconfig.write(outfile='config.ini')\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"write"})," function would generate the following output:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-makefile",children:";\n***\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);